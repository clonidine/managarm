#pragma once

#include <stdint.h>

namespace riscv {

enum class Csr : uint16_t {
	// Floating point control and status.
	fcsr = 0x3,
	// Supervisor trap setup.
	sstatus = 0x100, // Status register.
	sie = 0x104,     // Interrupt enable.
	stvec = 0x105,   // Trap vector address.
	senvcfg = 0x10A, // Environment configuration.
	// Supervisor trap handling.
	sscratch = 0x140,
	sepc = 0x141,     // Exception program counter.
	scause = 0x142,   // Cause of exception.
	stval = 0x143,    // Trap value.
	sip = 0x144,      // Interrupt pending.
	stimecmp = 0x14d, // Timer comparison register.
	// Indirect access CSRs.
	siselect = 0x150,
	sireg = 0x151,
	// Supervisor level interrupts.
	stopei = 0x15c,
	// Supervisor protection and translation.
	satp = 0x180, // Address translation.
};

namespace sstatus {

constexpr uint64_t sieBit = UINT64_C(1) << 1;  // Interrupt enable.
constexpr uint64_t spieBit = UINT64_C(1) << 5; // Previous interrupt enable.
constexpr uint64_t ubeBit = UINT64_C(1) << 6;  // U-mode is big endian or not.
constexpr uint64_t sppBit = UINT64_C(1) << 8;  // Previous privilege level (S-mode or not).
constexpr uint64_t sumBit = UINT64_C(1) << 18; // User memory access permitted in S-mode.
constexpr uint64_t mxrBit = UINT64_C(1)
                            << 19; // Executable page permission implies readable in S-mode.

// VS, FS, XS: floating point and vector extension state.
constexpr int vsShift = 9;
constexpr int fsShift = 13;
constexpr int xsShift = 15;

// Values for the VS, FS, XS fields.
constexpr uint64_t extMask = 3;
constexpr uint64_t extOff = 0;
constexpr uint64_t extInitial = 1;
constexpr uint64_t extClean = 2;
constexpr uint64_t extDirty = 3;

// U-mode execution width.
constexpr int uxlShift = 32;
constexpr uint64_t uxlMask = 3;
constexpr uint64_t uxl32 = 1;
constexpr uint64_t uxl64 = 2;
constexpr uint64_t uxl128 = 3;

} // namespace sstatus

namespace senvcfg {

// Enables the execution of `cbo.inval` in U-mode, the instruction performs a flush operation.
constexpr uint64_t cbie = UINT64_C(0b01) << 4;
// Enables the execution of `cbo.clean` and `cbo.flush` instructions in U-mode.
constexpr uint64_t cbcfe = UINT64_C(1) << 6;

} // namespace senvcfg

namespace interrupts {

constexpr uint64_t ssi = 1; // Supervisor software interrupt.
constexpr uint64_t sti = 5; // Supervisor timer interrupt.
constexpr uint64_t sei = 9; // Supervisor external interrupt.

} // namespace interrupts

// The CSR manipulation instructions on RISC-V take the CSR as an immediate operand.
// Since we do not want to add separate read/write functions for each CSR,
// using a template is out best option to ensure that the CSR is statically known.

template <Csr csr>
uint64_t readCsr() {
	uint64_t u;
	asm volatile("csrr %0, %1" : "=r"(u) : "i"(static_cast<uint16_t>(csr)) : "memory");
	return u;
}

template <Csr csr>
void writeCsr(uint64_t v) {
	asm volatile("csrw %1, %0" : : "r"(v), "i"(static_cast<uint16_t>(csr)) : "memory");
}

template <Csr csr>
uint64_t readWriteCsr(uint64_t v) {
	uint64_t u;
	asm volatile("csrrw %0, %1, %2" : "=r"(u) : "i"(static_cast<uint16_t>(csr)), "r"(v) : "memory");
	return u;
}

template <Csr csr>
void setCsrBits(uint64_t v) {
	asm volatile("csrs %1, %0" : : "r"(v), "i"(static_cast<uint16_t>(csr)) : "memory");
}

template <Csr csr>
void clearCsrBits(uint64_t v) {
	asm volatile("csrc %1, %0" : : "r"(v), "i"(static_cast<uint16_t>(csr)) : "memory");
}

} // namespace riscv
